;; @bundle-id: 6e133798b1a8
;; @source-rel: .gitcompile/JSON.ahk2
;; @source-sha1: 6126a42860f00b844b5cb9ebab8a6f2571a2af98
;; @note: Edit content below. Keep header lines starting with ';;' intact.
;; -------------------------
#Requires AutoHotkey v2.0

; JSON.ahk - A simple JSON implementation for AutoHotkey v2
; Because who needs a library when you can roll your own? ðŸ˜‰
; JSON.ahk - A simple JSON implementation for AutoHotkey v2
; Now with support for formatted JSON because even lazy people like pretty things! ðŸ˜‰
; JSON.ahk - Enhanced JSON implementation for AutoHotkey v2
; Now supports both dot notation AND bracket notation for lazy geniuses! ðŸ˜Ž
; JSON.ahk - Enhanced JSON implementation for AutoHotkey v2
; Now supports both dot notation AND bracket notation for lazy geniuses! ðŸ˜Ž
; JSON.ahk - Enhanced JSON implementation for AutoHotkey v2
; Now with ACTUAL working dot notation AND bracket notation! ðŸŽ¯

; JSON.ahk - Enhanced JSON implementation for AutoHotkey v2
; Working solution without fancy tricks! ðŸ’ª

class JSON {
    ; Parse JSON string to AHK object
    static Parse(jsonStr) {
        ; Clean up the JSON string but preserve string content
        jsonStr := this._CleanJSON(jsonStr)
        
        ; Handle different JSON types
        if (SubStr(jsonStr, 1, 1) = "{") {
            return this._ParseObject(jsonStr)
        } else if (SubStr(jsonStr, 1, 1) = "[") {
            return this._ParseArray(jsonStr)
        } else if (SubStr(jsonStr, 1, 1) = '"') {
            return this._ParseString(jsonStr)
        } else if (RegExMatch(jsonStr, "^-?\d+(\.\d+)?")) {
            return this._ParseNumber(jsonStr)
        } else if (jsonStr = "true" || jsonStr = "false") {
            return jsonStr = "true"
        } else if (jsonStr = "null") {
            return ""
        }
        
        Error("Invalid JSON: " . jsonStr)
    }
    
    ; Convert AHK object to JSON string
    static Stringify(obj, indent := 0) {
        indentStr := this._GetIndent(indent)
        nextIndent := this._GetIndent(indent + 1)
        
        ; Handle different types
        if (Type(obj) = "String") {
            return '"' . this._EscapeString(obj) . '"'
        } else if (Type(obj) = "Integer" || Type(obj) = "Float") {
            return String(obj)
        } else if (Type(obj) = "Array") {
            if (obj.Length = 0) {
                return "[]"
            }
            
            result := "[`n"
            for i, value in obj {
                result .= nextIndent . this.Stringify(value, indent + 1)
                if (i < obj.Length) {
                    result .= ","
                }
                result .= "`n"
            }
            result .= indentStr . "]"
            return result
        } else if (Type(obj) = "Object" || Type(obj) = "Map") {
            props := []
            
            ; Collect properties
            if (Type(obj) = "Map") {
                for key, value in obj {
                    props.Push({key: key, value: value})
                }
            } else {
                for key, value in obj.OwnProps() {
                    props.Push({key: key, value: value})
                }
            }
            
            if (props.Length = 0) {
                return "{}"
            }
            
            result := "{`n"
            for i, prop in props {
                result .= nextIndent . '"' . prop.key . '": ' . this.Stringify(prop.value, indent + 1)
                if (i < props.Length) {
                    result .= ","
                }
                result .= "`n"
            }
            result .= indentStr . "}"
            return result
        } else if (obj = "") {
            return "null"
        } else {
            return "null"
        }
    }
    
    ; Clean JSON while preserving string content
    static _CleanJSON(jsonStr) {
        result := ""
        inString := false
        escaped := false
        
        Loop Parse, jsonStr {
            char := A_LoopField
            
            if (inString) {
                result .= char
                if (escaped) {
                    escaped := false
                } else if (char = "\") {
                    escaped := true
                } else if (char = '"') {
                    inString := false
                }
            } else {
                ; Outside of strings, skip whitespace except what we need
                if (char = '"') {
                    inString := true
                    result .= char
                } else if (!RegExMatch(char, "\s")) {
                    result .= char
                } else if (result != "" && SubStr(result, -1) != " " && RegExMatch(SubStr(result, -1), "[,:\[\{\]\}]") = 0) {
                    ; Keep minimal spacing for readability
                    result .= " "
                }
            }
        }
        
        return Trim(result)
    }
    
    ; Private helper methods
    static _ParseObject(jsonStr) {
        ; Use Map for simplicity - we'll add syntactic sugar later if needed
        obj := Map()
        jsonStr := SubStr(jsonStr, 2) ; Remove opening {
        
        ; Empty object
        if (SubStr(Trim(jsonStr), 1, 1) = "}") {
            return obj
        }
        
        while (jsonStr) {
            jsonStr := LTrim(jsonStr)
            
            ; Check for closing }
            if (SubStr(jsonStr, 1, 1) = "}") {
                break
            }
            
            ; Parse key
            if (SubStr(jsonStr, 1, 1) != '"') {
                Error("Expected string key in: " . SubStr(jsonStr, 1, 50))
            }
            
            keyResult := this._ExtractQuotedString(jsonStr)
            key := keyResult.value
            jsonStr := keyResult.remaining
            jsonStr := LTrim(jsonStr)
            
            ; Expect colon
            if (SubStr(jsonStr, 1, 1) != ":") {
                Error("Expected colon after key")
            }
            jsonStr := LTrim(SubStr(jsonStr, 2))
            
            ; Parse value
            value := this._ExtractValue(jsonStr)
            obj[key] := value.value
            jsonStr := value.remaining
            
            ; Check for comma or closing }
            jsonStr := LTrim(jsonStr)
            if (SubStr(jsonStr, 1, 1) = ",") {
                jsonStr := SubStr(jsonStr, 2)
            } else if (SubStr(jsonStr, 1, 1) != "}") {
                Error("Expected comma or closing brace")
            }
        }
        
        return obj
    }
    
    static _ParseArray(jsonStr) {
        arr := []
        jsonStr := SubStr(jsonStr, 2) ; Remove opening [
        
        ; Empty array
        if (SubStr(Trim(jsonStr), 1, 1) = "]") {
            return arr
        }
        
        while (jsonStr) {
            jsonStr := LTrim(jsonStr)
            
            ; Check for closing ]
            if (SubStr(jsonStr, 1, 1) = "]") {
                break
            }
            
            ; Parse value
            value := this._ExtractValue(jsonStr)
            arr.Push(value.value)
            jsonStr := value.remaining
            
            ; Check for comma or closing ]
            jsonStr := LTrim(jsonStr)
            if (SubStr(jsonStr, 1, 1) = ",") {
                jsonStr := SubStr(jsonStr, 2)
            } else if (SubStr(jsonStr, 1, 1) != "]") {
                Error("Expected comma or closing bracket")
            }
        }
        
        return arr
    }
    
    static _ExtractValue(jsonStr) {
        jsonStr := LTrim(jsonStr)
        
        if (SubStr(jsonStr, 1, 1) = '"') {
            ; String
            return this._ExtractQuotedString(jsonStr)
        } else if (SubStr(jsonStr, 1, 1) = "{") {
            ; Object - need to find matching closing brace
            depth := 0
            inString := false
            escaped := false
            pos := 1
            
            Loop Parse, jsonStr {
                char := A_LoopField
                
                if (inString) {
                    if (escaped) {
                        escaped := false
                    } else if (char = "\") {
                        escaped := true
                    } else if (char = '"') {
                        inString := false
                    }
                } else {
                    if (char = '"') {
                        inString := true
                    } else if (char = "{") {
                        depth++
                    } else if (char = "}") {
                        depth--
                        if (depth = 0) {
                            objStr := SubStr(jsonStr, 1, pos)
                            return {value: this.Parse(objStr), remaining: SubStr(jsonStr, pos + 1)}
                        }
                    }
                }
                pos++
            }
            Error("Unterminated object")
        } else if (SubStr(jsonStr, 1, 1) = "[") {
            ; Array - need to find matching closing bracket
            depth := 0
            inString := false
            escaped := false
            pos := 1
            
            Loop Parse, jsonStr {
                char := A_LoopField
                
                if (inString) {
                    if (escaped) {
                        escaped := false
                    } else if (char = "\") {
                        escaped := true
                    } else if (char = '"') {
                        inString := false
                    }
                } else {
                    if (char = '"') {
                        inString := true
                    } else if (char = "[") {
                        depth++
                    } else if (char = "]") {
                        depth--
                        if (depth = 0) {
                            arrStr := SubStr(jsonStr, 1, pos)
                            return {value: this.Parse(arrStr), remaining: SubStr(jsonStr, pos + 1)}
                        }
                    }
                }
                pos++
            }
            Error("Unterminated array")
        } else if (RegExMatch(jsonStr, "^(-?\d+(\.\d+)?)", &match)) {
            ; Number
            return {value: Number(match[0]), remaining: SubStr(jsonStr, StrLen(match[0]) + 1)}
        } else if (SubStr(jsonStr, 1, 4) = "true") {
            return {value: true, remaining: SubStr(jsonStr, 5)}
        } else if (SubStr(jsonStr, 1, 5) = "false") {
            return {value: false, remaining: SubStr(jsonStr, 6)}
        } else if (SubStr(jsonStr, 1, 4) = "null") {
            return {value: "", remaining: SubStr(jsonStr, 5)}
        }
        
        Error("Invalid value: " . SubStr(jsonStr, 1, 20))
    }
    
    static _ExtractQuotedString(jsonStr) {
        if (SubStr(jsonStr, 1, 1) != '"') {
            Error("Expected quoted string")
        }
        
        pos := 2
        result := ""
        escaped := false
        
        while (pos <= StrLen(jsonStr)) {
            char := SubStr(jsonStr, pos, 1)
            
            if (escaped) {
                ; Handle escape sequences
                switch char {
                    case '"': result .= '"'
                    case '\': result .= '\'
                    case '/': result .= '/'
                    case 'b': result .= Chr(8)
                    case 'f': result .= Chr(12)
                    case 'n': result .= "`n"
                    case 'r': result .= "`r"
                    case 't': result .= "`t"
                    case 'u':
                        ; Unicode escape sequence \uXXXX
                        if (pos + 4 <= StrLen(jsonStr)) {
                            hex := SubStr(jsonStr, pos + 1, 4)
                            if (RegExMatch(hex, "^[0-9A-Fa-f]{4}$")) {
                                result .= Chr("0x" . hex)
                                pos += 4
                            } else {
                                result .= char
                            }
                        } else {
                            result .= char
                        }
                    default: result .= char
                }
                escaped := false
            } else if (char = "\") {
                escaped := true
            } else if (char = '"') {
                ; End of string found
                return {value: result, remaining: SubStr(jsonStr, pos + 1)}
            } else {
                result .= char
            }
            
            pos++
        }
        
        Error("Unterminated string")
    }
    
    static _ParseString(jsonStr) {
        result := this._ExtractQuotedString(jsonStr)
        return result.value
    }
    
    static _ParseNumber(jsonStr) {
        if (RegExMatch(jsonStr, "^(-?\d+(\.\d+)?)", &match)) {
            return Number(match[0])
        }
        Error("Invalid number: " . jsonStr)
    }
    
    static _EscapeString(str) {
        str := StrReplace(str, "\", "\\")
        str := StrReplace(str, '"', '\"')
        str := StrReplace(str, "`n", "\n")
        str := StrReplace(str, "`r", "\r")
        str := StrReplace(str, "`t", "\t")
        str := StrReplace(str, "/", "\/")
        str := StrReplace(str, Chr(8), "\b")
        str := StrReplace(str, Chr(12), "\f")
        return str
    }
    
    static _GetIndent(level) {
        indent := ""
        Loop level {
            indent .= "  "
        }
        return indent
    }
}

; Since AHK v2 Map already supports bracket notation, we can use it directly!
; The only limitation is you can't use dot notation with Maps, but that's a small price to pay

; Test the JSON parser
/*
testJSON := '
{
  "workers": [
    {
      "id": 1,
      "status": "ready",
      "sessionIndex": 0
    },
    {
      "id": 2,
      "status": "working",
      "sessionIndex": 1
    }
  ],
  "tasks": [
    {
      "id": "task_001",
      "tableName": "MARA",
      "status": "pending",
      "assignedWorker": 1
    }
  ]
}
'

; Parse the JSON
config := JSON.Parse(testJSON)

; Access with bracket notation (Maps support this natively!)
MsgBox("Worker 1 status: " . config["workers"][1]["status"])
MsgBox("Task table name: " . config["tasks"][1]["tableName"])

; Modify values
config["workers"][1]["status"] := "completed"
config["workers"][2]["status"] := "ready"

; Stringify it back
newJSON := JSON.Stringify(config)
MsgBox(newJSON, "Modified JSON")
*/

; Test the enhanced JSON parser
/*
testJSON := '
{
  "workers": [
    {
      "id": 1,
      "status": "ready",
      "sessionIndex": 0
    },
    {
      "id": 2,
      "status": "working",
      "sessionIndex": 1
    }
  ],
  "tasks": [
    {
      "id": "task_001",
      "tableName": "MARA",
      "status": "pending",
      "assignedWorker": 1
    }
  ]
}
'

; Parse the JSON
config := JSON.Parse(testJSON)

; Test both access methods
MsgBox("Worker 1 status (dot): " . config.workers[1].status)
MsgBox("Worker 1 status (bracket): " . config.workers[1]["status"])

; You can also mix them
MsgBox("Task table name: " . config["tasks"][1]["tableName"])

; Test modification
config.workers[1]["status"] := "completed"
config["workers"][2].status := "ready"

; Stringify it back
newJSON := JSON.Stringify(config)
MsgBox(newJSON, "Modified JSON")
*/
; Test the enhanced JSON parser
/*
testJSON := '
{
  "workers": [
    {
      "id": 1,
      "status": "ready",
      "sessionIndex": 0
    },
    {
      "id": 2,
      "status": "working",
      "sessionIndex": 1
    }
  ],
  "tasks": [
    {
      "id": "task_001",
      "tableName": "MARA",
      "status": "pending",
      "assignedWorker": 1
    }
  ]
}
'

; Parse the JSON
config := JSON.Parse(testJSON)

; Test both access methods
MsgBox("Worker 1 status (dot): " . config.workers[1].status)
MsgBox("Worker 1 status (bracket): " . config.workers[1]["status"])

; You can also mix them
MsgBox("Task table name: " . config["tasks"][1]["tableName"])

; Test modification
config.workers[1]["status"] := "completed"
config["workers"][2].status := "ready"

; Stringify it back
newJSON := JSON.Stringify(config)
MsgBox(newJSON, "Modified JSON")
*/


; Test the enhanced JSON parser
/*
testJSON := '
{
  "workers": [
    {
      "id": 1,
      "status": "ready",
      "sessionIndex": 0
    },
    {
      "id": 2,
      "status": "working",
      "sessionIndex": 1
    }
  ],
  "tasks": [
    {
      "id": "task_001",
      "tableName": "MARA",
      "status": "pending",
      "assignedWorker": 1
    }
  ]
}
'

; Parse the JSON
config := JSON.Parse(testJSON)

; Test both access methods
MsgBox("Worker 1 status (dot): " . config.workers[1].status)
MsgBox("Worker 1 status (bracket): " . config.workers[1]["status"])

; You can also mix them
MsgBox("Task table name: " . config["tasks"][1]["tableName"])

; Test modification
config.workers[1]["status"] := "completed"
config["workers"][2].status := "ready"

; Stringify it back
newJSON := JSON.Stringify(config)
MsgBox(newJSON, "Modified JSON")
*/

; JsonFile.ahk - File operations for our custom JSON format
; Because .json is too mainstream ðŸ˜Ž

class JsonFile {
    ; Save object to .jsn file
    static Save(filepath, obj) {
        ; Ensure .jsn extension
        if (!RegExMatch(filepath, "i)\.jsn$")) {
            filepath .= ".jsn"
        }
        
        ; Convert to JSON and add our special header
        jsonContent := "; SAP Helper JSON File v1.0" . "`n"
        jsonContent .= "; Generated: " . FormatTime(, "yyyy-MM-dd HH:mm:ss") . "`n"
        jsonContent .= "; User: " . A_UserName . "`n"
        jsonContent .= ";`n"
        jsonContent .= JSON.Stringify(obj)
        
        ; Write to file
        try {
            FileDelete(filepath)
        }
        FileAppend(jsonContent, filepath, "UTF-8")
        
        return filepath
    }
    
    ; Load object from .jsn file
    static Load(filepath) {
        ; Check if file exists
        if (!FileExist(filepath)) {
             Error("File not found: " . filepath)
        }
        
        ; Read file content
        content := FileRead(filepath, "UTF-8")
        
        ; Remove header comments
        lines := StrSplit(content, "`n")
        jsonLines := []
        
        for line in lines {
            if (!RegExMatch(line, "^\s*;")) {
                jsonLines.Push(line)
            }
        }
        
        jsonStr := ""
        for line in jsonLines {
            jsonStr .= line . "`n"
        }
        
        ; Parse JSON
        return JSON.Parse(Trim(jsonStr))
    }
    
    ; Check if file is valid .jsn format
    static IsValid(filepath) {
        try {
            this.Load(filepath)
            return true
        } catch {
            return false
        }
    }
}

; Example usage:
/*
; Create some data
data := Map(
    "sapConnection", Map(
        "system", "PRD",
        "client", "100",
        "user", "anonymusdennis"
    ),
    "preferences", Map(
        "autoLogin", true,
        "timeout", 300
    )
)

; Save to file
JsonFile.Save("sap_config.jsn", data)

; Load it back
loaded := JsonFile.Load("sap_config.jsn")
MsgBox("System: " . loaded["sapConnection"]["system"], "Loaded Config")
*/